#+LATEX_HEADER: \input{../lit-header}
#+TITLE: Selection
#+OPTIONS: ^:{}
:NOTE:
Going back to editing the rust code, directly, until I can get
this org mode interface a bit smoother.
:END:

* Bring dependencies into scope
#+NAME: bring dependencies into scope
#+BEGIN_SRC rust :tangle selector.rs :noweb tangle
  extern crate rand; 

  use std::thread::{spawn, JoinHandle};
  use std::sync::mpsc::{channel, Receiver, Sender};
  use std::cell::RefCell;
  use std::sync::{Arc,RwLock}; 
  use std::collections::VecDeque;

  use self::rand::{Rng, SeedableRng};
  use self::rand::isaac::Isaac64Rng;

  use par::statics::*;
  use gen::genotype::*;
  use gen::phenotype::{Creature,Fitness};
  use evo::crossover::{homologous_crossover};
  use fit::circbuf::{CircBuf};
#+END_SRC

* Selection on a Stream

One of the interesting design decisions that crystallized in engineering
this iteration of ROPER has been to treat the population as a cyclical
"stream", rather than as a mutable collection. 

The stream originates in with the seeder, proceeds through the hatchery,
on to the evaluator, and then to the selection and breeding actors, without
any need to synchronize a mutable population vector. What makes this feasible
is the way that Rust handles the ~Send~ trait: all that's transferred when a
~Creature~ is sent across a channel is the deed for ownership. This operation
is no slower than indexing into a vector, practically speaking. 

The only real speedbump lies with the selection actor. Sticking with tournament
selection for the time being, we want to retain some capacity to select the
combatants in a tournament /at random/. But randomly selecting from a stream
seems to require first collecting the incoming elements into a buffer. 

So, let there be a buffer. The selector will wait until ~n~ creatures have
arrived through the channel, and then perform tournament selection on that
buffer. Some number ~tsize~ of those creatures will be chosen for a tournament
-- perhaps several tournaments, in parallel. It will /take/ ~tsize~ creatures, 
on a secondary channel, then return ~tsize~ back, but of those ~tsize~, ~tsize/2~
will be the winners of the tournament, and ~tsize/2~ will be newborns.


** TODO Redesign this module

Basically, we have two paths we can take, here: either commit to the stateful approach, and
encase the creatures in RefCells /from the beginning/, so that we can mutate them in-place
-- an approach that is only weakly motivated by the current set up, since the selection window
is essentially ephemeral -- or, instead, commit to the functional and stream-oriented approach
we've taken elsewhere, and make the breeder functional. The tournament, e.g., doesn't /need/ to
mutate the window in-place. It can, instead, just return new creatures, transfer ownership of 
them on doing so, and then inject them back into the stream. 


** Spawning the selector/breeder

As creatures enter the breeding thread, through the =into_breeder_tx=
channel, they are assigned to a randomly chosen slot in the =arena=. 
When a second creature is assigned to the same slot -- when there is
a collision -- a tournament is triggered. The loser is destroyed, and
the winner is moved to a mating pool. 

When the mating pool has reached a certain capacity, its residents will
pair off according to compatibility. Each creature will pair with the
creature in the pool with whom it is most compatible. (We could introduce
some degree of noise into this selection as well.) 

The mating pairs then reproduce through homologous crossover, and then
both the parents and the offspring are returned to the population stream.

The arena needs:
- a channel to recv creatures from the breeder thread
- a channel to send creatures to the mating thread
- a channel to recv creatures from the mating thread
- a channel to send creatures back to the breeder thread
  (or to the next phase in the evolution stream)
 
We can probably reuse the pattern that we've already used in
the hatchery and elsewhere. 


#+NAME: spawn the arena
#+BEGIN_SRC rust :tangle selector.rs :noweb tangle
#+END_SRC

#+NAME: spawn the selector 
#+BEGIN_SRC rust :tangle selector.rs :noweb tangle
  pub fn spawn_breeder(
      window_size: usize,
      rng_seed: RngSeed,
  ) -> (Sender<Creature>, Receiver<Creature>, JoinHandle<()>) {
      let (from_breeder_tx, from_breeder_rx) = channel();
      let (into_breeder_tx, into_breeder_rx) = channel();

      let sel_handle = spawn(move || {
        /* TODO */
        for incoming in into_breeder_rx {
          /* STUB, because the spice must flow */
          from_breeder_tx.send(incoming);
        }
      });

      (into_breeder_tx, from_breeder_rx, sel_handle)
  }
#+END_SRC

** Selection functions

To work with the form of homologous crossover implemented in the
~emu::crossover~ module, we may wish to use simple mate selection
algorithm, which increases the likelihood that mating pairs will
have "compatible" crossover masks. But this is a probabilistically
delicate operation. We don't want to create a perverse incentive
that will incline the population towards crossover masks that consist
entirely of ~1~ bits (and so which are /maximally compatible/ with other
masks), simply for the sake of increasing their likelihood of being
chosen for tournaments. 

On the other hand, this incentive will only turn out to be "perverse"
if it overwhelms the selective pressure (which we have theoretically
grounded reasons to expect) for sparse crossover masks. It could turn
out to be a useful, countervailing pressure that inclines the masks
to be as dense as possible, without losing the benefits of sparseness.
(The benefit of a sparse crossover mask, of course, is that it reduces
the probability of destructive crossover.)

#+NAME: measure crossover mask compatibility
#+BEGIN_SRC rust :tangle selector.rs :noweb tangle

    fn xover_compat(c1: u64, c2: u64) -> usize {
        (c1 & c2).count_ones() as usize
    }
  /* FOOBAR */
#+END_SRC

The static variable ~MATE_SELECTION_FACTOR~ will be used...

#+NAME: perform selection and mating
#+BEGIN_SRC rust :tangle selector.rs :noweb tangle

    fn tournament(selection_window: &mut VecDeque<Creature>,
                  seed: RngSeed) -> (RngSeed, Vec<Creature>) {
        let mut rng = Isaac64Rng::from_seed(seed);
        /* note: seed creation should probably be its own utility function */
        let mut new_seed: [u8; 32] = [0; 32];
        for i in 0..32 { new_seed[i] = rng.gen::<u8>() }

        assert!(*TSIZE as f32 * *MATE_SELECTION_FACTOR <= selection_window.len() as f32);
        let mut indices = rand::seq::sample_indices(&mut rng,
                                                    selection_window.len(),
                                                    (*TSIZE as f32 * *MATE_SELECTION_FACTOR)
                                                    .floor() as usize);
        /* TODO: take n times as many combatants as needed, then winnow
         ,* out those least compatible with first combatant's crossover mask
         ,*/
        let x1 = selection_window[0].genome.xbits;
        let xbit_vec : Vec<u64> = selection_window.iter().map(|c| c.genome.xbits).collect();
        let compatkey = |i: &usize| {
            let x2 = xbit_vec[*i];

            64 - xover_compat(x1, x2)
        };

        indices.sort_by_key(compatkey);
        /* now drop the least compatible from consideration */
        indices.truncate(*TSIZE);

        let fitkey = |i: &usize| {
          0 /* FIXME */
        };
        /* now, sort the remaining indices by the fitness of their creatures */
        /* TODO -- we need a pareto sorting function */
        indices.sort_by_key(fitkey);
        /* and choose the parents and the fallen */
        // *TSIZE must be >= 4.
        let (p0, p1) = (indices[*TSIZE-1], indices[*TSIZE-2]);
        let (d0, d1) = (indices[0], indices[1]);

     /* I think I need to have the selection window consist of refcells of creatures, 
        instead of just naked creatures */ /* FIXME */ 
        let (mother, father) = (&selection_window[p0], &selection_window[p1]);
        let offspring = homologous_crossover(mother, father, &mut rng);
        /* now, place the offspring back in the population by inserting them
         ,* into the selection window
         ,*/

        (new_seed, offspring)
    }
#+END_SRC


